@startmindmap main
* JavaScript 对象
** 理解对象
*** 属性类型
**** 数据属性（[[Configurable]] etc.）
**** 访问器属性（[[Getter]]、[[Setter]]）
*** 定义属性
*** 读取属性

** 创建对象
*** 工厂模式（抽象了具体的创建过程，但是无法识别对象类型）
*** 构造函数模式（解决了工厂模式的弊端，但是会出现代码无法复用的问题）
*** 原型模式（共享所有类型————引用类型问题）
**** 理解 prototype 和 __proto__
**** 通过 isProtoypeOf() 或者 getPrototypOf() 来测试原型
**** hasOwnProperty 来自实例
**** in 来自实例和原型
**** for in 来自实例和原型的可枚举属性
**** Object.keys() 返回可枚举的实例属性
**** Object.getOwnPropertyNames() 返回所有实例属性（可枚举&不可枚举）
*** 组合使用构造函数模式和原型模式（被公共认可的模式）
*** 动态原型模式（上述组合的改造版，动态判断是否要初始化原型）
*** 寄生构造函数模式（除了拥有 new 操作符，跟工厂模式类似，不建议使用）
*** 稳妥构造函数模式

** 继承对象
*** 原型链继承（引用类型问题）
**** 理解原型链
**** instanceof 的原理，可以于 isProtoypeOf() 相互替换使用
*** 借用构造函数————经典继承（方法不能够复用）
*** 组合继承————伪经典继承（会调用两次父类型的构造函数）
*** 寄生式继承（方法不能复用）
*** 寄生组合式继承
@endmindmap