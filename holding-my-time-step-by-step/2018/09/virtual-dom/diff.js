/**
 * 核心思想:
 * 新的节点的 tagName 或者 key 和旧的不同, 这种情况代表需要替换旧的节点, 并且也不再需要遍历子节点
 * 新的节点的 tagName 和 key 和旧的相同, 开始遍历子树
 * 没有新的节点，那么什么都不用做
 */

import { StateEnums, isString, move } from './util';
import Element from './element';

export default function diff(oldDomTree, newDomTree) {
    // 用于记录差异
    let pathchs = {};
    // 一开始的索引为 0
    dfs(oldDomTree, newDomTree, 0, pathchs);
    return pathchs;
}

function dfs(oldNode, newNode, index, patches) {
    // 用于保存子树的更改
    let curPatches = [];
    // 需要判断三种情况
    // 1.没有新的节点，那么什么都不用做
    // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换
    // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树
    if (!newNode) {
    } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) {
        // 判断属性是否变更
        let props = diffProps(oldNode.props, newNode.props);
        if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props });
        // 遍历子树
        diffChildren(oldNode.children, newNode.children, index, patches);
    } else {
        // 节点不同，直接替换
        curPatches.push({ type: StateEnums.Replace, node: newNode });
    }
    if (curPatches.length) {
        if (patches[index]) {
            patches[index] = patches[index].concat(curPatches);
        } else {
            patches[index] = curPatches;
        }
    }
}

/**
 * 判断属性的更改
 */
function diffProps(oldProps, newProps) {
    // 判断 Props 分以下三步骤
    // 先遍历 oldProps 查看是否存在删除的属性
    // 然后遍历 newProps 查看是否有属性值被修改
    // 最后查看是否有属性新增
    let change = [];
    for (const key in oldProps) {
        if (oldProps.hasOwnProperty(key) && !newProps[key]) {
            change.push({
                prop: key
            });
        }
    }
    for (const key in newProps) {
        if (newProps.hasOwnProperty(key)) {
            const prop = newProps[key];
            if (oldProps[key] && oldProps[key] !== newProps[key]) {
                change.push({
                    prop: key,
                    value: newProps[key]
                })
            } else if (!oldProps[key]) {
                change.push({
                    prop: key,
                    value: newProps[key]
                });
            }
        }
    }
    return change;
}

/**
 * 判断列表差异算法实现
 */
function listDiff(oldList, newList, index, patches) {
    // 为了遍历方便，先取出两个 list 的所有 keys
    let oldKeys = getKeys(oldList);
    let newKeys = getKeys(newList);
    let changes = [];
    // 用于保存变更后的节点数据
    // 使用该数组保存有以下好处
    // 1. 可以正确获得被删除节点索引
    // 2. 交换节点位置只需要操作一遍 DOM
    // 3. 用于 `diffChildren` 函数中的判断，只需要遍历
    // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要
    // 再去判断一遍
    let list = [];
    oldList &&
        oldList.forEach(item => {
            let key = item.key;
            if (isString(item)) {
                key = item;
            }
            // 寻找新的 children 中是否含有当前节点
            // 没有的话需要删除
            let index = newKeys.indexOf(key)
            if (index === -1) {
                list.push(null);
            } else {
                list.push(key);
            }
        });
    // 遍历变更后的数组
    let length = list.length;
    // 因为删除数组元素是会更改索引的
    // 所有从后往前删可以保证索引不变
    for (let i = length - 1; i >= 0; i--) {
        // 判断当前元素是否为空，为空表示需要删除
        if (!list[i]) {
            list.splice(i, 1);
            changes.push({
                type: StateEnums.Remove,
                index: i
            });
        }
    }
    // 遍历新的 list，判断是否有节点新增或移动
    // 同时也对 `list` 做节点新增和移动节点的操作
    newList &&
        newList.forEach(item => {
            let key = item.key;
            if (isString(item)) {
                key = item;
            }
            // 寻找旧的 children 中是否含有当前节点
            let index = list.indexOf(key);
            // 没找到代表新节点，需要插入
            if (index === -1  || key == null) {
                changes.push({
                    type: StateEnums.Insert,
                    node: item,
                    index: i
                })
                list.splice(i, 0, key);
            } else {
                // 找到了，需要判断是否需要移动
                if (index !== i) {
                    changes.push({
                        type: StateEnums.Move,
                        from: index,
                        to: i
                    });
                    move(list, index, i);
                }
            }
        })
    return { changes, list };
}

/**
 * 遍历子元素打标识
 */
function diffChildren(oldChild, newChild, index, patches) {
    let { changes, list } = listDiff(oldChild, newChild, index, patches);
    if (changes.length) {
        if (patches[index]) {
            patches[index] = patches[index].concat(changes);
        } else {
            patches[index] = changes;
        }
    }

    // 记录上一个遍历过的节点
    oldList &&
        oldList.forEach((item, i) => {
            let child = item && item.children;
            if (child) {
                index = last && last.children ? index + last.children.length + 1 : index + 1;
                let keyIndex = list.indexOf(item.key);
                let node = newChild[keyIndex];
                // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历
                if (node) {
                    dfs(item, node, index, patches)
                }
            } else {
                index += 1;
            }
            last = item;
        });
}

function getKeys(list) {
    let keys = []
    let text
    list &&
        list.forEach(item => {
            let key;
            if (isString(item)) {
                key = [item];
            } else if (item instanceof Element) {
                key = item.key;
            }
            keys.push(key);
      })
    return keys;
}